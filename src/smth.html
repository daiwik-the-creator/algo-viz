<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Texture Example</title>
  <style>
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="webgl-canvas"></canvas>
<script>
  // Set up the WebGL context
  const canvas = document.getElementById("webgl-canvas");
  const gl = canvas.getContext("webgl");

  if (!gl) {
    alert("WebGL not supported!");
  }

  // Vertex shader program
  const vertexShaderSource = `
    attribute vec4 a_position;
    attribute vec2 a_texCoord;
    varying vec2 v_texCoord;
    uniform mat4 u_modelViewMatrix;
    uniform mat4 u_projectionMatrix;

    void main() {
      gl_Position = u_projectionMatrix * u_modelViewMatrix * a_position;
      v_texCoord = a_texCoord;
    }
  `;

  // Fragment shader program
  const fragmentShaderSource = `
    precision mediump float;
    varying vec2 v_texCoord;
    uniform sampler2D u_texture;

    void main() {
      gl_FragColor = texture2D(u_texture, v_texCoord);
    }
  `;

  // Create shaders
  function createShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('ERROR compiling shader: ', gl.getShaderInfoLog(shader));
      return null;
    }
    return shader;
  }

  // Create the shader program
  function createProgram(vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('ERROR linking program: ', gl.getProgramInfoLog(program));
      return null;
    }
    return program;
  }

  // Initialize shaders
  const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
  const shaderProgram = createProgram(vertexShader, fragmentShader);

  // Get attribute and uniform locations
  const a_position = gl.getAttribLocation(shaderProgram, "a_position");
  const a_texCoord = gl.getAttribLocation(shaderProgram, "a_texCoord");
  const u_modelViewMatrix = gl.getUniformLocation(shaderProgram, "u_modelViewMatrix");
  const u_projectionMatrix = gl.getUniformLocation(shaderProgram, "u_projectionMatrix");
  const u_texture = gl.getUniformLocation(shaderProgram, "u_texture");

  // Cube vertices (with texture coordinates)
  const vertices = new Float32Array([
    // Positions          // Texture coordinates
    -1.0, -1.0,  1.0,    0.0, 0.0,
     1.0, -1.0,  1.0,    1.0, 0.0,
     1.0,  1.0,  1.0,    1.0, 1.0,
    -1.0,  1.0,  1.0,    0.0, 1.0,

    -1.0, -1.0, -1.0,    0.0, 0.0,
     1.0, -1.0, -1.0,    1.0, 0.0,
     1.0,  1.0, -1.0,    1.0, 1.0,
    -1.0,  1.0, -1.0,    0.0, 1.0,
  ]);

  const indices = new Uint16Array([
    0, 1, 2,  0, 2, 3,  // front
    4, 5, 6,  4, 6, 7,  // back
    0, 1, 5,  0, 5, 4,  // bottom
    2, 3, 7,  2, 7, 6,  // top
    0, 3, 7,  0, 7, 4,  // left
    1, 2, 6,  1, 6, 5,  // right
  ]);

  // Set up buffers for the cube
  const vertexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  const indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  // Load the texture
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  const image = new Image();
  image.src = "tex.jpg";  // Replace with your texture image path
  image.onload = function() {
    console.log('Texture loaded');
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

    // Check if the texture is non-power-of-two and set the appropriate parameters
    if (isPowerOfTwo(image.width) && isPowerOfTwo(image.height)) {
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }

    render();
  };

  // Function to check if a number is a power of two
  function isPowerOfTwo(value) {
    return (value & (value - 1)) === 0;
  }

  // Rendering function
  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.useProgram(shaderProgram);

    // Set up the model-view and projection matrices
    const modelViewMatrix = mat4.create(); // You would need to include or create mat4
    const projectionMatrix = mat4.create(); // You would need to include or create mat4
    mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
    mat4.lookAt(modelViewMatrix, [0.0, 0.0, 5.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0]);

    gl.uniformMatrix4fv(u_modelViewMatrix, false, modelViewMatrix);
    gl.uniformMatrix4fv(u_projectionMatrix, false, projectionMatrix);

    // Enable the attribute arrays
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 5 * Float32Array.BYTES_PER_ELEMENT, 0);
    gl.enableVertexAttribArray(a_position);
    gl.vertexAttribPointer(a_texCoord, 2, gl.FLOAT, false, 5 * Float32Array.BYTES_PER_ELEMENT, 3 * Float32Array.BYTES_PER_ELEMENT);
    gl.enableVertexAttribArray(a_texCoord);

    // Set the texture uniform
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(u_texture, 0);

    // Draw the cube
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

    // Request next frame
    requestAnimationFrame(render);
  }

  // Set the canvas size
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
</script>
</body>
</html>
